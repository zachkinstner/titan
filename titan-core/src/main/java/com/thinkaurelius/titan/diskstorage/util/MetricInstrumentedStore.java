package com.thinkaurelius.titan.diskstorage.util;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.codahale.metrics.Counter;
import com.codahale.metrics.Histogram;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Timer;
import com.thinkaurelius.titan.diskstorage.StaticBuffer;
import com.thinkaurelius.titan.diskstorage.StorageException;
import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;
import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeySliceQuery;
import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
import com.thinkaurelius.titan.util.stats.MetricManager;

/**
 * This class instruments an arbitrary KeyColumnValueStore backend with Metrics.
 * The cumulative runtime of, number of invocations of, and number of exceptions
 * thrown by each interface method are instrumented with Metrics (using Timer,
 * Counter, and Counter again, respectively). The Metric names are generated by
 * calling {@link MetricRegistry#name(backendClass, methodName, identifier)},
 * where methodName is the exact name of the method including capitalization,
 * and identifier is "time", "calls", or "exceptions".
 * <p>
 * In addition to the three standard metrics, {@code getSlice} and
 * {@code getKeys} have some additional metrics related to their return values.
 * {@code getSlice} carries metrics with the identifiers "entries-returned" and
 * "entries-histogram". The first is a counter of total Entry objects returned.
 * The second is a histogram of the size of Entry lists returned.
 * {@code getKeys} returns a {@link RecordIterator} that manages metrics for its
 * methods.
 * <p>
 * This implementation does not catch any exceptions. Exceptions emitted by the
 * backend store implementation are guaranteed to pass through this
 * implementation's methods.
 * <p>
 * The implementation includes repeated {@code try...catch} boilerplate that
 * could be reduced by using reflection to determine the method name and by
 * delegating Metrics object handling to a common helper that takes a Callable
 * closure, but I'm not sure that the extra complexity and potential performance
 * hit is worth it.
 * 
 * @author Dan LaRocque <dalaro@hopcount.org>
 */
public class MetricInstrumentedStore implements KeyColumnValueStore {
    
    private final KeyColumnValueStore backend;
    
    // containsKey
    private final Timer   containsKeyTimer;
    private final Counter containsKeyInvocationCounter;
    private final Counter containsKeyFailureCounter;
    // getSlice
    private final Timer   getSliceTimer;
    private final Counter getSliceColumnCounter;
    private final Histogram getSliceColumnHisto;
    private final Counter getSliceInvocationCounter;
    private final Counter getSliceFailureCounter;
    // mutate
    private final Timer   mutateTimer;
    private final Counter mutateInvocationCounter;
    private final Counter mutateFailureCounter;
    // acquireLock
    private final Timer   acquireLockTimer;
    private final Counter acquireLockInvocationCounter;
    private final Counter acquireLockFailureCounter;
    // getKeys
    private final Timer   getKeysTimer;
    private final Counter getKeysInvocationCounter;
    private final Counter getKeysFailureCounter;
    private final String  getKeysIteratorMetricPrefix;
    // getLocalKeyPartition
    private final Timer   getLocalKeyPartitionTimer;
    private final Counter getLocalKeyPartitionInvocationCounter;
    private final Counter getLocalKeyPartitionFailureCounter;
    // getName
    private final Timer   getNameTimer;
    private final Counter getNameInvocationCounter;
    private final Counter getNameFailureCounter;
    // close
    private final Timer   closeTimer;
    private final Counter closeInvocationCounter;
    private final Counter closeFailureCounter;
    
    private static final Logger log =
            LoggerFactory.getLogger(MetricInstrumentedStore.class);

    public MetricInstrumentedStore(KeyColumnValueStore backend, String p) {
        this.backend = backend;

        MetricRegistry metrics = MetricManager.INSTANCE.getRegistry();
        
        containsKeyTimer =
                  metrics.timer(MetricRegistry.name(p, "containsKey", "time"));
        containsKeyInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "containsKey", "calls"));
        containsKeyFailureCounter =
                metrics.counter(MetricRegistry.name(p, "containsKey", "exceptions"));
        
        getSliceTimer =
                  metrics.timer(MetricRegistry.name(p, "getSlice", "time"));
        getSliceInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getSlice", "calls"));
        getSliceFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getSlice", "exceptions"));
        getSliceColumnCounter =
                metrics.counter(MetricRegistry.name(p, "getSlice", "entries-returned"));
        getSliceColumnHisto =
              metrics.histogram(MetricRegistry.name(p, "getSlice", "entries-histogram"));
        
        mutateTimer =
                  metrics.timer(MetricRegistry.name(p, "mutate", "time"));
        mutateInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "mutate", "calls"));
        mutateFailureCounter =
                metrics.counter(MetricRegistry.name(p, "mutate", "exceptions"));
        
        acquireLockTimer =
                  metrics.timer(MetricRegistry.name(p, "acquireLock", "time"));
        acquireLockInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "acquireLock", "calls"));
        acquireLockFailureCounter =
                metrics.counter(MetricRegistry.name(p, "acquireLock", "exceptions"));
        
        getKeysTimer =
                  metrics.timer(MetricRegistry.name(p, "getKeys", "time"));
        getKeysInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getKeys", "calls"));
        getKeysFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getKeys", "exceptions"));
        getKeysIteratorMetricPrefix = p + "." + "getKeys.iterator";
        
        getLocalKeyPartitionTimer =
                  metrics.timer(MetricRegistry.name(p, "getLocalKeyPartition", "time"));
        getLocalKeyPartitionInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getLocalKeyPartition", "calls"));
        getLocalKeyPartitionFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getLocalKeyPartition", "exceptions"));
        
        getNameTimer =
                  metrics.timer(MetricRegistry.name(p, "getName", "time"));
        getNameInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "getName", "calls"));
        getNameFailureCounter =
                metrics.counter(MetricRegistry.name(p, "getName", "exceptions"));
        
        closeTimer =
                  metrics.timer(MetricRegistry.name(p, "close", "time"));
        closeInvocationCounter =
                metrics.counter(MetricRegistry.name(p, "close", "calls"));
        closeFailureCounter =
                metrics.counter(MetricRegistry.name(p, "close", "exceptions"));
        
        log.debug("Wrapped Metrics around store {} (metric prefix {})", backend, p);
    }

    @Override
    public boolean containsKey(StaticBuffer key, StoreTransaction txh)
            throws StorageException {
        boolean ok = false;
        containsKeyInvocationCounter.inc();
        final Timer.Context tc = containsKeyTimer.time();
        try {
            final boolean result = backend.containsKey(key, txh);
            ok = true;
            return result;
        } finally {
            tc.stop();
            if (!ok) containsKeyFailureCounter.inc();
        }
    }

    @Override
    public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh)
            throws StorageException {
        boolean ok = false;
        getSliceInvocationCounter.inc();
        final Timer.Context tc = getSliceTimer.time();
        try {
            final List<Entry> result = backend.getSlice(query, txh);
            final int size = result.size();
            getSliceColumnCounter.inc(size);
            getSliceColumnHisto.update(size);
            ok = true;
            return result;
        } finally {
            tc.stop();
            if (!ok) getSliceFailureCounter.inc();
        }
           
    }

    @Override
    public void mutate(StaticBuffer key, List<Entry> additions,
            List<StaticBuffer> deletions, StoreTransaction txh)
            throws StorageException {
        boolean ok = false;
        mutateInvocationCounter.inc();
        final Timer.Context tc = mutateTimer.time();
        try  {
            backend.mutate(key, additions, deletions, txh);
            ok = true;
        } finally {
            tc.stop();
            if (!ok) mutateFailureCounter.inc();
        }
    }

    @Override
    public void acquireLock(StaticBuffer key, StaticBuffer column,
            StaticBuffer expectedValue, StoreTransaction txh)
            throws StorageException {
        boolean ok = false;
        acquireLockInvocationCounter.inc();
        final Timer.Context tc = acquireLockTimer.time();
        try {
            backend.acquireLock(key, column, expectedValue, txh);
            ok = true;
        } finally {
            tc.stop();
            if (!ok) acquireLockFailureCounter.inc();
        }
    }

    @Override
    public RecordIterator<StaticBuffer> getKeys(StoreTransaction txh)
            throws StorageException {
        boolean ok = false;
        getKeysInvocationCounter.inc();
        final Timer.Context tc = getKeysTimer.time();
        try {
            final RecordIterator<StaticBuffer> iter = backend.getKeys(txh);
            ok = true;
            return MetricInstrumentedIterator.of(iter, getKeysIteratorMetricPrefix);
        } finally {
            tc.stop();
            if (!ok) getKeysFailureCounter.inc();
        }
    }

    @Override
    public StaticBuffer[] getLocalKeyPartition() throws StorageException {
        boolean ok = false;
        getLocalKeyPartitionInvocationCounter.inc();
        final Timer.Context tc = getLocalKeyPartitionTimer.time();
        try {
            final StaticBuffer[] result = backend.getLocalKeyPartition();
            ok = true;
            return result;
        } finally {
            tc.stop();
            if (!ok) getLocalKeyPartitionFailureCounter.inc();
        }
    }

    @Override
    public String getName() {
        boolean ok = false;
        getNameInvocationCounter.inc();
        final Timer.Context tc = getNameTimer.time();
        try {
            final String result = backend.getName();
            ok = true;
            return result;
        } finally {
            tc.stop();
            if (!ok) getNameFailureCounter.inc();
        }
    }

    @Override
    public void close() throws StorageException {
        boolean ok = false;
        closeInvocationCounter.inc();
        final Timer.Context tc = closeTimer.time();
        try {
            backend.close();
            ok = true;
        } finally {
            tc.stop();
            if (!ok) closeFailureCounter.inc();
        }
    }
}
